#!/usr/bin/env python
# -*- coding:utf-8 -*- 


##############################################################################
## license :
##============================================================================
##
## File :        LinacAlbaSimulator.py
## 
## Project :     LinacAlbaSimulator
##
## This file is part of Tango device class.
## 
## Tango is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
## 
## Tango is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
## 
## You should have received a copy of the GNU General Public License
## along with Tango.  If not, see <http://www.gnu.org/licenses/>.
## 
##
## $Author :      sblanch$
##
## $Revision :    $
##
## $Date :        $
##
## $HeadUrl :     $
##============================================================================
##            This file is generated by POGO
##    (Program Obviously used to Generate tango Object)
##
##        (c) - Software Engineering Group - ESRF
##############################################################################

"""Device server to simulate the behaviour of the Alba,s linac PLCs (siemens s7)"""

__all__ = ["LinacAlbaSimulator", "LinacAlbaSimulatorClass", "main"]

__docformat__ = 'restructuredtext'

import PyTango
import sys
# Add additional import
#----- PROTECTED REGION ID(LinacAlbaSimulator.additionnal_import) ENABLED START -----#
import time
import traceback
import socket
import select
import threading
import array,struct
import random

#---- memory map getter
import plc1,plc2,plc3,plck
def getPlcNumber(plc_type):
    if   plc_type == "plc1": return 1
    elif plc_type == "plc2": return 2
    elif plc_type == "plc3": return 3
    elif plc_type == "plc4": return 4
    elif plc_type == "plc5": return 5
    else: return None
def getPlcPort(plc_number):
    return 2010+plc_number
def getPlc(plc_number):
    if plc_number == 1:
        return plc1
    elif plc_number == 2:
        return plc2
    elif plc_number == 3:
        return plc3
    elif plc_number in [4,5]:
        return plck
    return None

BACKLOG = 1#only wait for one connection.

#---- Memory map positions convertions
def quartet2float(quartet):
    bar = array.array('f')
    foo = array.array('B',quartet[::-1]).tostring()
    bar.fromstring(foo)
    return bar[0]
def float2quartet(value):
    return array.array('B',struct.pack('>f',value))
def pair2short(pair):
    bar = array.array('h')
    foo = array.array('B',pair[::-1]).tostring()
    bar.fromstring(foo)
    return bar[0]
def short2pair(value):
    return array.array('B',struct.pack('>h',value))

#---- Noise readings functions
def noise(center,std):
    #---- TODO: in writable values the center must be the setpoint (when on)
    #---- FIXME: With the new value as a center, the deviation make the value 
    #            drift away from the original.
    return random.normalvariate(center,std)

#----- PROTECTED REGION END -----#	//	LinacAlbaSimulator.additionnal_import

## Device States Description
## No states for this device

class LinacAlbaSimulator (PyTango.Device_4Impl):

    #--------- Add you global variables here --------------------------
    #----- PROTECTED REGION ID(LinacAlbaSimulator.global_variables) ENABLED START -----#
    def listener(self):
        E = ()
        self.buildSocketListener()
        while not self.joinEventIsSet():
            try:
                self.__connection.send(self.__memoryMap.tostring())
                ready = select.select( [self.__connection.fileno()], E,E, 0)
                if ready[0]:
                    recv = self.__connection.recv(self.__plc.WRITESIZE)
                    if len(recv) != 0:
                        receiver = threading.Thread(target=self.processInputReceived,
                                                    args=([recv]))
                        receiver.setDaemon(True)
                        receiver.start()
                    else:
                        self.warn_stream("(%d) nothing received"%(self.Port))
                self.updateHeartbeat()
                self.updateRegisters()
                time.sleep(self.attr_HeartbeatPeriod_read)
            except Exception,e:
                self.debug_stream("(%d) Exiting the loop due to Exception: %s"
                                  %(self.Port,e))
                try: connection.close()
                except: pass
                self.buildSocketListener()
        connection.close()
    def buildSocketListener(self):
        self.__socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.__socket.bind((self.Host,self.Port))
        self.__socket.listen(BACKLOG)
        self.info_stream("PLC listener prepared (%d)."%(self.Port))
        self.__connection,address = self.__socket.accept()
        self.debug_stream("PLC connection accepted (port %d, descriptor %d)."
                          %(self.Port,self.__connection.fileno()))
    def joinEventIsSet(self):
        return self.__joinerEvent.isSet()
    def setJoinEvent(self):
        self.__joinerEvent.set()
        print("(%d) join event set"%(self.Port))
    def setDefaultRegisters(self):
        try:
            for k in self.__plc.attributes.keys():
                attribute = self.__plc.attributes[k]
                try:
                    value = attribute['read_value']
                    register = attribute['read_addr']
                    if attribute['type'] == ('f', 4):
                        for index,element in enumerate(float2quartet(value)):
                            self.__memoryMap[register+index] = element
                    elif attribute['type'] == ('h', 2):
                        for index,element in enumerate(short2pair(value)):
                            self.__memoryMap[register+index] = element
                    elif attribute['type'] == ('B', 1):
                        self.__memoryMap[register] = value
                    elif attribute['type'] == PyTango.DevBoolean:
                        bit = attribute['read_bit']
                        value << bit
                        self.__memoryMap[register] |= value
                    else:
                        self.error_stream("(%d) setDefaultRegisters: not "\
                                          "understood %s type"
                                          %(self.Port,attribute['type']))
                except Exception,e:
                    self.error_stream("(%d) setDefaultRegisters, key %s "\
                                      "exception: %s"%(self.Port,k,e))
                    traceback.format_exc(e)
        except Exception,e:
            self.error_stream("(%d) setDefaultRegisters, defaults key loop "\
                              "exception: %s"%(self.Port,e))
            traceback.format_exc(e)
    def updateHeartbeat(self):
        address = self.__plc.attributes['HeartBeat']['read_addr']
        self.__memoryMap[address] = int(not bool(self.__memoryMap[address]))
        #self.debug_stream("Heartbeat %d"%(self.__memoryMap[address]))
    def updateRegisters(self):
        try:
            for k in self.__plc.attributes.keys():
                attribute = self.__plc.attributes[k]
                #Check, if it's an Wattribute if the value must be update
                try:
                    if attribute.has_key('write_addr') and \
                       not attribute['write_value'] == attribute['read_value']:
                        #---- TODO: there are attributes that its write can modify others
                        if attribute.has_key('step'):
                            if attribute['write_value'] < attribute['read_value']:
                                attribute['read_value'] -= attribute['step']
                            elif attribute['write_value'] > attribute['read_value']:
                                attribute['read_value'] += attribute['step']
                            self.debug_stream("(%d) updateRegisters: step the "\
                                              "value"%(self.Port))
                        else:
                            attribute['read_value'] = attribute['write_value']
                            self.debug_stream("(%d) updateRegisters: apply "\
                                              "the write value of %s"%(self.Port,k))
                except Exception,e:
                    self.error_stream("(%d) updateRegisters: exception in "\
                                      "step of key %s: %s"%(self.Port,k,e))
                    traceback.format_exc(e)
                #check it this ROattribute becomes the readback of another Wattribute
                try:
                    #TODO: there is the possibility to include a formula eval here
                    if attribute.has_key('reference'):
                        referenceAttr = self.__plc.attributes[attribute['reference']]
                        if not attribute['read_value'] == referenceAttr['read_value']:
                            if attribute.has_key('step'):
                                if referenceAttr['read_value'] < attribute['read_value']:
                                    attribute['read_value'] -= attribute['step']
                                elif referenceAttr['read_value'] > attribute['read_value']:
                                    attribute['read_value'] += attribute['step']
                                self.debug_stream("(%d) updateRegisters: step the "\
                                                  "value to the reference"%(self.Port))
                            else:
                                attribute['read_value'] = referenceAttr['read_value']
                                self.debug_stream("(%d) updateRegisters: apply "\
                                              "the reference read value of %s"%(self.Port,k))
                except Exception,e:
                    self.error_stream("(%d) updateRegisters: exception in "\
                                      "readback of key %s: %s"%(self.Port,k,e))
                    traceback.format_exc(e)
                #check if the value has some noise in the reading to make it.
                try:
                    if attribute.has_key('updatable') and \
                       attribute['updatable'] == True:
                        #use the recorded value to introduce noise to it,
                        # this avoids a drift due to noise of noised
#                        register = attribute['read_addr']
                        value = noise(attribute['read_value'],\
                                      attribute['std'])
                except Exception,e:
                    self.error_stream("(%d) updateRegisters: exception in the "\
                                      "update of key %s: %s"%(self.Port,k,e))
                    traceback.format_exc(e)
                #after the three possibilities:
                #  - apply to the read_value what is in the write_value (or an step)
                #  - follow the reference value if there is
                #  - apply some noise to the reading
                #it's time to place this value to the memory map that will be 
                #transmitted to the reader
                self.__apply2mem(k, attribute)
        except Exception,e:
            self.error_stream("(%d) updateRegisters: loop exception: %s"
                              %(self.Port,e))
            traceback.format_exc(e)
        #self.debug_stream(self.__memoryMap)
    def processInputReceived(self,inputs):
        inputMap = array.array('B')
        inputMap.fromstring(inputs)
        self.debug_stream("(%d) received as array %s"%(self.Port,inputMap))
        for k in self.__plc.attributes.keys():
            attribute = self.__plc.attributes[k]
            try:
                if attribute.has_key('write_addr'):
                    register = attribute['write_addr']
                    if attribute['type'] == ('f', 4):
                        value = quartet2float(inputMap[register:register+4])
                    elif attribute['type'] == ('h', 2):
                        value = pair2short(inputMap[register:register+2])
                    elif attribute['type'] == ('B', 1):
                        value = int(inputMap[register])
                    elif attribute['type'] == PyTango.DevBoolean:
                        bit = attribute['write_bit']
                        value = bool(int(inputMap[register]) & 1 << bit)
                    else:
                        self.error_stream("(%d) processInputReceived: not "\
                                          "understood %s type"
                                          %(self.Port,attribute['type']))
                        value = attribute['write_value'] #To avoid exception
                    if not value == attribute['write_value']:
                        self.debug_stream("(%d) processInputReceived: new "\
                                          "wvalue for %s"%(self.Port,k))
                        attribute['write_value'] = value
            except Exception,e:
                self.error_stream("(%d) processInputReceived: exception "\
                                  "in key %s: %s"%(self.Port,k,e))
                traceback.format_exc(e)
                
    def __apply2mem(self,name,attribute):
        register = attribute['read_addr']
        value = attribute['read_value']
        if attribute['type'] == ('f', 4):
            for index,element in enumerate(float2quartet(value)):
                self.__memoryMap[register+index] = element
        elif attribute['type'] == ('h', 2):
            for index,element in enumerate(short2pair(int(value))):
                self.__memoryMap[register+index] = element
        elif attribute['type'] == ('B', 1):
            self.__memoryMap[register] = int(value)
        elif attribute['type'] == PyTango.DevBoolean:
            bit = attribute['read_bit']
            byte = self.__memoryMap[register]
            byte |= bool(value) << bit
            self.__memoryMap[register] = byte
        else:
            self.error_stream("(%d) __apply2mem: not understood %s type for %s"
                              %(self.Port,valuetype,name))
    #----- PROTECTED REGION END -----#	//	LinacAlbaSimulator.global_variables

    def __init__(self,cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)
        self.debug_stream("In __init__()")
        LinacAlbaSimulator.init_device(self)
        #----- PROTECTED REGION ID(LinacAlbaSimulator.__init__) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	LinacAlbaSimulator.__init__
        
    def delete_device(self):
        self.debug_stream("In delete_device()")
        #----- PROTECTED REGION ID(LinacAlbaSimulator.delete_device) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	LinacAlbaSimulator.delete_device

    def init_device(self):
        self.debug_stream("In init_device()")
        self.get_device_properties(self.get_device_class())
        self.attr_HeartbeatPeriod_read = 0.0
        self.attr_Lock4labview_read = False
        #----- PROTECTED REGION ID(LinacAlbaSimulator.init_device) ENABLED START -----#
        self.attr_HeartbeatPeriod_read = 1.0#even it's memorised, this must never be 0.
        self.Host = '0.0.0.0'#this means for eth interface
        #self.Host = '127.0.0.1'#this means only for the loopback interface
        plcNum = getPlcNumber(self.plcType)
        self.Port = getPlcPort(plcNum)
        self.__plc = getPlc(plcNum)
        self.__memoryMap = self.__plc.memoryMap
        self.setDefaultRegisters()
        self.__socket = None
        self.__connection = None
        self.__joinerEvent = threading.Event()#to communicate between threads
        self.__joinerEvent.clear()
        self.__thread = threading.Thread(target=self.listener)
        self.__thread.setDaemon(True)
        self.__thread.start()
        #----- PROTECTED REGION END -----#	//	LinacAlbaSimulator.init_device

    def always_executed_hook(self):
        self.debug_stream("In always_excuted_hook()")
        #----- PROTECTED REGION ID(LinacAlbaSimulator.always_executed_hook) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	LinacAlbaSimulator.always_executed_hook

    #-----------------------------------------------------------------------------
    #    LinacAlbaSimulator read/write attribute methods
    #-----------------------------------------------------------------------------
    
    def read_HeartbeatPeriod(self, attr):
        self.debug_stream("In read_HeartbeatPeriod()")
        #----- PROTECTED REGION ID(LinacAlbaSimulator.HeartbeatPeriod_read) ENABLED START -----#
        attr.set_value(self.attr_HeartbeatPeriod_read)
        
        #----- PROTECTED REGION END -----#	//	LinacAlbaSimulator.HeartbeatPeriod_read
        
    def write_HeartbeatPeriod(self, attr):
        self.debug_stream("In write_HeartbeatPeriod()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(LinacAlbaSimulator.HeartbeatPeriod_write) ENABLED START -----#
        self.attr_HeartbeatPeriod_read = data
        #----- PROTECTED REGION END -----#	//	LinacAlbaSimulator.HeartbeatPeriod_write
        
    def read_Lock4labview(self, attr):
        self.debug_stream("In read_Lock4labview()")
        #----- PROTECTED REGION ID(LinacAlbaSimulator.Lock4labview_read) ENABLED START -----#
        register = self.__plc.attributes['Lock_ST']['read_addr']
        attr.set_value(self.__memoryMap[register] == 1 or False)
        
        #----- PROTECTED REGION END -----#	//	LinacAlbaSimulator.Lock4labview_read
        
    def write_Lock4labview(self, attr):
        self.debug_stream("In write_Lock4labview()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(LinacAlbaSimulator.Lock4labview_write) ENABLED START -----#
        register = self.__plc.attributes['Lock_ST']['read_addr']
        if self.__memoryMap[register] in [0,1]:
            self.__memoryMap[register] = data
        #----- PROTECTED REGION END -----#	//	LinacAlbaSimulator.Lock4labview_write
        
    
    
        #----- PROTECTED REGION ID(LinacAlbaSimulator.initialize_dynamic_attributes) ENABLED START -----#
    def initialize_dynamic_attributes(self):
        pass
        #----- PROTECTED REGION END -----#	//	LinacAlbaSimulator.initialize_dynamic_attributes
            
    def read_attr_hardware(self, data):
        self.debug_stream("In read_attr_hardware()")
        #----- PROTECTED REGION ID(LinacAlbaSimulator.read_attr_hardware) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	LinacAlbaSimulator.read_attr_hardware


    #-----------------------------------------------------------------------------
    #    LinacAlbaSimulator command methods
    #-----------------------------------------------------------------------------
    

class LinacAlbaSimulatorClass(PyTango.DeviceClass):
    #--------- Add you global class variables here --------------------------
    #----- PROTECTED REGION ID(LinacAlbaSimulator.global_class_variables) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	LinacAlbaSimulator.global_class_variables

    def dyn_attr(self, dev_list):
        """Invoked to create dynamic attributes for the given devices.
        Default implementation calls
        :meth:`LinacAlbaSimulator.initialize_dynamic_attributes` for each device
    
        :param dev_list: list of devices
        :type dev_list: :class:`PyTango.DeviceImpl`"""
    
        for dev in dev_list:
            try:
                dev.initialize_dynamic_attributes()
            except:
                import traceback
                dev.warn_stream("Failed to initialize dynamic attributes")
                dev.debug_stream("Details: " + traceback.format_exc())
        #----- PROTECTED REGION ID(LinacAlbaSimulator.dyn_attr) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	LinacAlbaSimulator.dyn_attr

    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        'plcType':
            [PyTango.DevString,
            "plc1,plc2,plc3,plc4,plc5",
            [] ],
        }


    #    Command definitions
    cmd_list = {
        }


    #    Attribute definitions
    attr_list = {
        'HeartbeatPeriod':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Heartbeat Period",
                'unit': "s",
                'description': "Internal loop to refresh the memory table.",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'Lock4labview':
            [[PyTango.DevBoolean,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'description': "With this attribute is represented the action of locking a plc from the labview manufacturer application",
                'Memorized':"true"
            } ],
        }


def main():
    try:
        py = PyTango.Util(sys.argv)
        py.add_class(LinacAlbaSimulatorClass,LinacAlbaSimulator,'LinacAlbaSimulator')

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed,e:
        print '-------> Received a DevFailed exception:',e
    except Exception,e:
        print '-------> An unforeseen exception occured....',e

if __name__ == '__main__':
    main()
